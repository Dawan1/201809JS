### 变量提升
在当前作用域下，代码执行之前，对带var和function关键字的进行声明和定义
函数执行的步骤：
1.形成一个私有的作用域
2.形参赋值
3.变量提升
4.代码从上往下执行

### 作用域
全局作用域 全局变量
私有作用域 私有变量：形参和带var关键字
作用域查找变量顺序：
- 先看是否是私有的，若是则操作时私有变量，与外界无关
- 若不是，往上级作用域查找，若上级作用域也没找到，则继续往上级查找，直到找到window,若window下也没有，则报错
由当前作用域往上级作用域，然后再往上级作用域，直到到window,这样就形成了作用域链

### 变量提升的细节知识点
- 只对等号左边的进行变量提升
- 函数作为值存在时，不进行变量提升
- 重名变量不会重复声明，但会重复定义
- 自执行函数本身不进行变量提升，但是内部还是要进行变量提升
- 不管条件是否成立，对var关键字要进行声明，对function关键字的，标准浏览器下是只声明不定义，IE浏览器是声明+定义

### 闭包
- 函数运行时形成一个不受外界干扰的私有作用域，这就是一个闭包,闭包是一种机制
- 封装性
- 保护的作用，防止里面的内容跟外界冲突和覆盖
#### 闭包的几种形式
- 自执行函数
- 函数的返回值是一个小函数 例如：
    function fn(){
        return function(){
        }
    }
>利用预处理的思想：先在fn大函数里，先提前处理公有的内容，等到return后面小函数运行时会用到提前处理的内容 例如bind方法封装就利用了这种思想
- 自执行函数内部返回对象 (高级单例模式)
> 解决了公有和私有的问题

### 作用域销毁
全局作用域：页面关闭时销毁
私有作用域：立即销毁  不立即销毁   不销毁
正常情况下，方法运行完后，产生作用域的就会销毁，但也有些特殊情况：
 1.当一个函数A返回值是另一个函数时，这个函数A不会立即销毁，等返回这个小函数运行完后，这个函数A才销毁  -这叫不立即销毁
 2.当函数内部的内容被外界占用了，这个函数就不销毁
 
堆内存销毁：
如果堆内存的引用地址被变量给占用了，这时堆内存不会销毁，只有没有变量指向这个堆内存时，浏览器会在空闲时回收这块内存，这称为垃圾回收机制 （标准浏览器下回收的机制）

### this 
调用的主体





 
